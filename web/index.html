<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>CGM Signal + Events Explorer</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Literata:opsz,wght@7..72,400;600&family=Syne:wght@400;600;700&display=swap");

      :root {
        color-scheme: light;
        --ink: #1f1a14;
        --muted: #6f6255;
        --canvas: #f6f0e6;
        --panel: #fff8ee;
        --accent: #c04a2b;
        --accent-2: #0f6b6b;
        --grid: rgba(31, 26, 20, 0.14);
        --shadow: 0 20px 45px rgba(32, 22, 14, 0.18);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Literata", "Times New Roman", serif;
        color: var(--ink);
        background: var(--canvas);
      }

      .backdrop {
        position: fixed;
        inset: 0;
        background:
          radial-gradient(circle at top left, rgba(192, 74, 43, 0.22), transparent 45%),
          radial-gradient(circle at 80% 20%, rgba(15, 107, 107, 0.2), transparent 42%),
          linear-gradient(135deg, rgba(255, 248, 238, 0.65), rgba(246, 240, 230, 0.95));
        z-index: -2;
      }

      .grain {
        position: fixed;
        inset: 0;
        background-image:
          url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='120' height='120' viewBox='0 0 120 120'><filter id='n'><feTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='1' stitchTiles='stitch'/></filter><rect width='120' height='120' filter='url(%23n)' opacity='0.12'/></svg>");
        mix-blend-mode: multiply;
        opacity: 0.5;
        z-index: -1;
        pointer-events: none;
      }

      header {
        padding: 32px 32px 0;
      }

      .hero {
        display: grid;
        gap: 16px;
        padding: 24px 28px;
        border-radius: 24px;
        background: var(--panel);
        box-shadow: var(--shadow);
        border: 1px solid rgba(31, 26, 20, 0.08);
        animation: rise 700ms ease forwards;
      }

      .eyebrow {
        text-transform: uppercase;
        letter-spacing: 0.18em;
        font-size: 11px;
        font-weight: 600;
        color: var(--accent-2);
      }

      h1 {
        margin: 0;
        font-family: "Syne", "Arial Black", sans-serif;
        font-size: clamp(28px, 4vw, 40px);
        letter-spacing: -0.02em;
      }

      .lede {
        margin: 0;
        color: var(--muted);
        max-width: 60ch;
      }

      main {
        padding: 24px 32px 40px;
        display: grid;
        gap: 24px;
      }

      .panel {
        background: var(--panel);
        border-radius: 24px;
        padding: 20px;
        box-shadow: var(--shadow);
        border: 1px solid rgba(31, 26, 20, 0.08);
      }

      .case {
        display: grid;
        gap: 16px;
      }

      .case-head {
        display: grid;
        gap: 4px;
      }

      .case-title {
        font-family: "Syne", sans-serif;
        font-size: 18px;
        margin: 0;
      }

      .case-meta {
        font-size: 12px;
        color: var(--muted);
      }

      .summary {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .stat {
        padding: 8px 12px;
        border-radius: 999px;
        border: 1px solid rgba(31, 26, 20, 0.12);
        background: rgba(255, 255, 255, 0.8);
        font-size: 12px;
      }

      .chart-panel {
        display: grid;
        gap: 12px;
      }

      .chart-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }

      .chart-header h2 {
        margin: 0;
        font-family: "Syne", sans-serif;
        font-size: 16px;
      }

      .legend {
        display: flex;
        gap: 12px;
        align-items: center;
        font-size: 12px;
        color: var(--muted);
      }

      .legend span {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .legend i {
        width: 14px;
        height: 2px;
        background: var(--accent);
        display: inline-block;
      }

      .case-controls {
        margin-top: 18px;
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
        color: var(--muted);
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.12em;
      }

      .case-controls select {
        font-size: 13px;
        text-transform: none;
        letter-spacing: 0.02em;
        padding: 8px 12px;
        border-radius: 12px;
        border: 1px solid rgba(31, 26, 20, 0.18);
        background: rgba(255, 255, 255, 0.85);
        color: var(--ink);
        font-family: "Literata", serif;
      }

      canvas {
        width: 100%;
        height: 260px;
        display: block;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.6);
      }

      .case-details {
        display: grid;
        gap: 16px;
      }

      .case-details.two-up {
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      }

      .subpanel h3 {
        margin: 0 0 12px;
        font-family: "Syne", sans-serif;
      }

      .subpanel ul {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 12px;
      }

      .subpanel li {
        padding: 10px 12px;
        border-radius: 14px;
        border: 1px dashed rgba(31, 26, 20, 0.15);
        background: rgba(255, 255, 255, 0.7);
        font-size: 13px;
      }

      .event-item {
        cursor: pointer;
        transition: border 0.2s ease, background 0.2s ease;
      }

      .event-item.is-active {
        border-color: rgba(192, 74, 43, 0.45);
        background: rgba(255, 244, 238, 0.9);
      }

      .metric-card.is-active {
        border-color: rgba(192, 74, 43, 0.45);
        box-shadow: 0 12px 28px rgba(31, 26, 20, 0.12);
      }

      .metrics ul {
        gap: 10px;
      }

      .metric-card {
        padding: 12px 14px;
        border-radius: 16px;
        border: 1px solid rgba(31, 26, 20, 0.12);
        background: rgba(255, 255, 255, 0.85);
        cursor: pointer;
      }

      .metric-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 6px;
      }

      .status-chip {
        padding: 2px 8px;
        border-radius: 999px;
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        font-weight: 600;
        border: 1px solid transparent;
      }

      .status-green {
        color: #134d2b;
        background: rgba(121, 210, 150, 0.35);
        border-color: rgba(19, 77, 43, 0.3);
      }

      .status-yellow {
        color: #7a4a12;
        background: rgba(255, 206, 120, 0.38);
        border-color: rgba(122, 74, 18, 0.3);
      }

      .status-red {
        color: #7a1f1f;
        background: rgba(230, 120, 120, 0.3);
        border-color: rgba(122, 31, 31, 0.32);
      }

      .status-gray {
        color: #5a524a;
        background: rgba(180, 174, 166, 0.35);
        border-color: rgba(90, 82, 74, 0.3);
      }

      .trigger-list {
        margin: 6px 0 8px;
        padding-left: 16px;
        color: var(--muted);
        font-size: 12px;
      }

      .metric-title {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 6px;
      }

      .metric-row {
        display: flex;
        justify-content: space-between;
        gap: 8px;
        font-size: 12px;
        padding: 4px 0;
        border-bottom: 1px dashed rgba(31, 26, 20, 0.08);
      }

      .metric-row:last-child {
        border-bottom: none;
      }

      .metric-name {
        font-weight: 600;
      }

      .metric-value {
        color: var(--accent-2);
        font-weight: 600;
      }

      .metric-detail {
        color: var(--muted);
      }

      .metrics-glossary {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 10px;
        font-size: 13px;
        color: var(--muted);
      }

      .metrics-glossary li {
        padding: 10px 12px;
        border-radius: 14px;
        border: 1px solid rgba(31, 26, 20, 0.12);
        background: rgba(255, 255, 255, 0.85);
      }

      .metrics-glossary strong {
        color: var(--ink);
        font-family: "Syne", sans-serif;
        font-weight: 600;
      }

      .note {
        font-size: 12px;
        color: var(--muted);
      }

      footer {
        padding: 0 32px 32px;
        font-size: 12px;
        color: var(--muted);
      }

      @keyframes rise {
        from {
          opacity: 0;
          transform: translateY(12px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @media (max-width: 980px) {
        canvas {
          height: 280px;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        * {
          animation: none !important;
          transition: none !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="backdrop"></div>
    <div class="grain"></div>
    <header>
      <section class="hero">
        <div class="title-block">
          <div class="eyebrow">N-of-1 CGM notebook</div>
          <h1>Signal + Events Explorer</h1>
          <p class="lede">
            Visual inspection of CGM time series with meal events. Load
            <code>output/cgm.json</code> and optionally <code>output/events.json</code>
            to verify coverage, timing, and context.
          </p>
        </div>
        <div id="case-controls" class="case-controls"></div>
      </section>
    </header>
    <main id="cases"></main>
    <footer>Data stays local. This viewer reads JSON files from the repo.</footer>
    <script>
      const CASE_INDEX_URLS = ["../output/cases.json", "./cases.json"];

      function parseTimestamp(value) {
        return new Date(value);
      }

      function formatTimestampShort(value) {
        if (!value || typeof value !== "string") return "unknown time";
        const trimmed = value.replace("T", " ");
        return trimmed.slice(0, 16);
      }

      function formatDateLabel(date) {
        const pad = (num) => String(num).padStart(2, "0");
        return `${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(date.getHours())}:00`;
      }

      function safeMinMax(values) {
        let min = Infinity;
        let max = -Infinity;
        for (const value of values) {
          if (value < min) min = value;
          if (value > max) max = value;
        }
        if (!isFinite(min) || !isFinite(max)) {
          return [0, 1];
        }
        return [min, max];
      }

      function drawGrid(ctx, width, height, padding, minValue, maxValue, axisHeight = 0) {
        const plotBottom = height - padding - axisHeight;
        const plotHeight = plotBottom - padding;
        ctx.strokeStyle = "rgba(31, 26, 20, 0.14)";
        ctx.lineWidth = 1;
        for (let i = 0; i <= 4; i++) {
          const y = padding + plotHeight * (i / 4);
          ctx.beginPath();
          ctx.moveTo(padding, y);
          ctx.lineTo(width - padding, y);
          ctx.stroke();

          const value = maxValue - (maxValue - minValue) * (i / 4);
          ctx.fillStyle = "#6f6255";
          ctx.font = "11px Literata, serif";
          ctx.textAlign = "right";
          ctx.textBaseline = "middle";
          ctx.fillText(value.toFixed(1), padding - 8, y);
        }
      }

      function alignToHalfDay(date) {
        const aligned = new Date(date.getTime());
        aligned.setMinutes(0, 0, 0);
        const hour = aligned.getHours();
        aligned.setHours(hour < 12 ? 0 : 12);
        if (aligned > date) {
          aligned.setHours(aligned.getHours() - 12);
        }
        return aligned;
      }

      function drawTimeAxis(ctx, minTime, maxTime, xScale, padding, width, plotBottom, axisHeight) {
        const step = 12 * 60 * 60 * 1000;
        const start = alignToHalfDay(minTime);
        const end = maxTime.getTime();
        ctx.strokeStyle = "rgba(31, 26, 20, 0.38)";
        ctx.fillStyle = "#3f352c";
        ctx.font = "12px Literata, serif";
        ctx.textBaseline = "top";
        const yTick = plotBottom;
        const yLabel = yTick + 10;

        ctx.beginPath();
        ctx.moveTo(padding, plotBottom);
        ctx.lineTo(width - padding, plotBottom);
        ctx.stroke();

        let first = true;
        for (let t = start.getTime(); t <= end; t += step) {
          const x = xScale(new Date(t));
          if (first) {
            ctx.textAlign = "left";
            first = false;
          } else if (t + step > end) {
            ctx.textAlign = "right";
          } else {
            ctx.textAlign = "center";
          }
          ctx.beginPath();
          ctx.moveTo(x, yTick);
          ctx.lineTo(x, yTick + 6);
          ctx.stroke();
          ctx.fillText(formatDateLabel(new Date(t)), x, yLabel);
        }
      }

      function drawAxisLabels(ctx, width, height, padding, plotBottom, unit) {
        return;
      }

      function drawLine(ctx, points) {
        ctx.strokeStyle = "#c04a2b";
        ctx.lineWidth = 2;
        ctx.beginPath();
        points.forEach(([x, y], idx) => {
          if (idx === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();
      }

      function drawWindowHighlight(ctx, startMs, endMs, xScale, padding, plotBottom, color) {
        if (startMs >= endMs) return;
        const xStart = xScale(new Date(startMs));
        const xEnd = xScale(new Date(endMs));
        const width = Math.max(1, xEnd - xStart);
        ctx.fillStyle = color;
        ctx.fillRect(xStart, padding, width, plotBottom - padding);
      }

      function drawThresholdFill(
        ctx,
        sampleTimes,
        sampleValues,
        windowStart,
        windowEnd,
        threshold,
        xScale,
        yScale,
        plotBottom,
        color
      ) {
        const segments = [];
        let current = [];

        for (let i = 0; i < sampleTimes.length - 1; i++) {
          const t1 = sampleTimes[i];
          const t2 = sampleTimes[i + 1];
          if (t2 < windowStart || t1 > windowEnd) continue;

          const segStart = Math.max(t1, windowStart);
          const segEnd = Math.min(t2, windowEnd);
          if (segStart > segEnd) continue;

          const v1 = sampleValues[i];
          const v2 = sampleValues[i + 1];
          const interp = (t) => v1 + ((v2 - v1) * (t - t1)) / (t2 - t1);
          const vStart = segStart === t1 ? v1 : interp(segStart);
          const vEnd = segEnd === t2 ? v2 : interp(segEnd);

          const startAbove = vStart >= threshold;
          const endAbove = vEnd >= threshold;

          if (startAbove && endAbove) {
            if (!current.length) current.push({ t: segStart, v: vStart });
            current.push({ t: segEnd, v: vEnd });
            continue;
          }

          if (!startAbove && !endAbove) {
            if (current.length >= 2) {
              segments.push(current);
            }
            current = [];
            continue;
          }

          const tCross = segStart + ((threshold - vStart) * (segEnd - segStart)) / (vEnd - vStart);
          const vCross = threshold;

          if (startAbove && !endAbove) {
            if (!current.length) current.push({ t: segStart, v: vStart });
            current.push({ t: tCross, v: vCross });
            if (current.length >= 2) {
              segments.push(current);
            }
            current = [];
          } else if (!startAbove && endAbove) {
            current = [{ t: tCross, v: vCross }, { t: segEnd, v: vEnd }];
          }
        }

        if (current.length >= 2) {
          segments.push(current);
        }

        if (!segments.length) return;

        const yThreshold = yScale(threshold);
        ctx.fillStyle = color;

        segments.forEach((segment) => {
          ctx.beginPath();
          ctx.moveTo(xScale(new Date(segment[0].t)), yScale(segment[0].v));
          for (let i = 1; i < segment.length; i++) {
            ctx.lineTo(xScale(new Date(segment[i].t)), yScale(segment[i].v));
          }
          const last = segment[segment.length - 1];
          const first = segment[0];
          ctx.lineTo(xScale(new Date(last.t)), yThreshold);
          ctx.lineTo(xScale(new Date(first.t)), yThreshold);
          ctx.closePath();
          ctx.fill();
        });
      }

      function drawEvents(ctx, events, xScale, padding, plotBottom, selectedEventId) {
        events.forEach((event) => {
          const x = xScale(parseTimestamp(event.start_time));
          ctx.strokeStyle = event.event_id === selectedEventId
            ? "rgba(192, 74, 43, 0.7)"
            : "rgba(31, 26, 20, 0.32)";
          ctx.lineWidth = event.event_id === selectedEventId ? 2 : 1;
          ctx.beginPath();
          ctx.moveTo(x, padding);
          ctx.lineTo(x, plotBottom);
          ctx.stroke();
        });
        ctx.lineWidth = 1;
      }

      function renderEventsList(events, selectedEventId, onSelect) {
        const list = document.createElement("ul");
        if (!events.length) {
          const item = document.createElement("li");
          item.textContent = "No events found.";
          list.appendChild(item);
          return list;
        }
        events.forEach((event) => {
          const item = document.createElement("li");
          item.className = "event-item";
          if (event.event_id === selectedEventId) {
            item.classList.add("is-active");
          }
          const label = event.label || event.event_id || "event";
          item.textContent = `${formatTimestampShort(event.start_time)} - ${label}`;
          item.addEventListener("click", () => {
            if (event.event_id) onSelect(event.event_id);
          });
          list.appendChild(item);
        });
        return list;
      }

      function formatMetricValue(metric) {
        const rawValue = Number(metric.value);
        const unit = metric.unit || "";
        if (!Number.isFinite(rawValue)) {
          return `n/a ${unit}`;
        }
        return `${rawValue.toFixed(2)} ${unit}`;
      }

      function formatMetricName(name) {
        if (name === "iAUC") return "iAUC_0-120";
        return name || "metric";
      }

      function formatMetricDetail(metric) {
        const coverage = metric.coverage_ratio ?? metric.quality_summary?.coverage_percentage;
        const coveragePercent = coverage === undefined
          ? null
          : Number(coverage) * (coverage <= 1 ? 100 : 1);
        const returnPercent = metric.quality_summary?.return_toward_baseline_percentage;
        const details = [];

        if (coveragePercent !== null && Number.isFinite(coveragePercent)) {
          details.push(`coverage ${coveragePercent.toFixed(0)}%`);
        }
        if (metric.metric_name === "recovery_slope" && returnPercent !== null && returnPercent !== undefined) {
          const parsed = Number(returnPercent);
          if (Number.isFinite(parsed)) {
            details.push(`return ${parsed.toFixed(1)}%`);
          }
        }

        return details.join(" · ");
      }

      function renderMetricsList(metrics, eventMap, signalsMap, selectedEventId, onSelect) {
        const list = document.createElement("ul");
        if (!metrics.length) {
          const item = document.createElement("li");
          item.textContent = "No metrics found.";
          list.appendChild(item);
          return list;
        }

        const grouped = new Map();
        metrics.forEach((metric) => {
          const eventId = metric.event_id || "unknown";
          if (!grouped.has(eventId)) grouped.set(eventId, []);
          grouped.get(eventId).push(metric);
        });

        Array.from(grouped.entries()).forEach(([eventId, group]) => {
          const card = document.createElement("li");
          card.className = "metric-card";
          if (eventId === selectedEventId) {
            card.classList.add("is-active");
          }
          card.addEventListener("click", () => onSelect(eventId));

          const event = eventMap.get(eventId);
          const titleRow = document.createElement("div");
          titleRow.className = "metric-header";
          const title = document.createElement("div");
          title.className = "metric-title";
          const label = event ? (event.label || event.event_id) : eventId;
          const time = event ? formatTimestampShort(event.start_time) : "unknown time";
          title.textContent = `${time} · ${label}`;
          titleRow.appendChild(title);

          const signal = signalsMap?.get(eventId);
          if (signal) {
            const chip = document.createElement("span");
            const status = signal.status || "green";
            chip.className = `status-chip status-${status}`;
            chip.textContent = status;
            titleRow.appendChild(chip);
          }
          card.appendChild(titleRow);

          if (signal && signal.triggers && signal.triggers.length) {
            const triggers = document.createElement("ul");
            triggers.className = "trigger-list";
            signal.triggers.forEach((trigger) => {
              const item = document.createElement("li");
              item.textContent = trigger.message || trigger.metric || "trigger";
              triggers.appendChild(item);
            });
            card.appendChild(triggers);
          }

          group.forEach((metric) => {
            const row = document.createElement("div");
            row.className = "metric-row";

            const name = document.createElement("span");
            name.className = "metric-name";
            name.textContent = formatMetricName(metric.metric_name);

            const value = document.createElement("span");
            value.className = "metric-value";
            value.textContent = formatMetricValue(metric);

            const detail = document.createElement("span");
            detail.className = "metric-detail";
            detail.textContent = formatMetricDetail(metric);

            row.appendChild(name);
            row.appendChild(value);
            row.appendChild(detail);
            card.appendChild(row);
          });

          list.appendChild(card);
        });

        return list;
      }

      async function loadJson(url) {
        try {
          const response = await fetch(url);
          if (!response.ok) return null;
          return await response.json();
        } catch (err) {
          return null;
        }
      }

      async function loadCaseIndex() {
        for (const url of CASE_INDEX_URLS) {
          const data = await loadJson(url);
          if (data) {
            return {
              data,
              baseDir: url.replace(/\/cases\.json$/, ""),
            };
          }
        }
        return { data: null, baseDir: null };
      }

      function resolveCasePath(caseConfig, baseDir) {
        const raw = caseConfig.path || caseConfig.slug || caseConfig.title || "";
        if (!raw) return baseDir || "";
        if (raw.startsWith(".") || raw.startsWith("/")) return raw;
        if (!baseDir) return raw;
        return `${baseDir}/${raw}`;
      }

      function sortCases(cases) {
        return cases.slice().sort((a, b) => {
          const aTime = a.end_time ? Date.parse(a.end_time) : 0;
          const bTime = b.end_time ? Date.parse(b.end_time) : 0;
          return bTime - aTime;
        });
      }

      async function renderCase(caseConfig) {
        const basePath = caseConfig.path || "../output";
        const cgm = await loadJson(`${basePath}/cgm.json`);
        if (!cgm) {
          const error = document.createElement("section");
          error.className = "panel";
          error.textContent = `Missing cgm.json for ${caseConfig.title || basePath}`;
          return error;
        }

        const samples = cgm.samples || [];
        const times = samples.map((s) => parseTimestamp(s.timestamp));
        const values = samples.map((s) => Number(s.glucose_value));
        const [, rawMaxValue] = safeMinMax(values);
        const minValue = 0;
        const maxValue = Math.max(1, Math.ceil(rawMaxValue) + 1);

        const minTime = new Date(Math.min(...times.map((t) => t.getTime())));
        const maxTime = new Date(Math.max(...times.map((t) => t.getTime())));

        const eventsData = await loadJson(`${basePath}/events.json`);
        const events = eventsData ? eventsData.events || [] : [];
        const eventMap = new Map();
        events.forEach((event) => {
          if (event.event_id) eventMap.set(event.event_id, event);
        });

        const metricsData = await loadJson(`${basePath}/metrics.json`);
        const metrics = metricsData ? metricsData.metrics || [] : [];

        const signalsData = await loadJson(`${basePath}/event_signals.json`);
        const signals = signalsData ? signalsData.events || [] : [];
        const signalsMap = new Map();
        signals.forEach((signal) => {
          if (signal.event_id) signalsMap.set(signal.event_id, signal);
        });

        const eventOrder = events.map((event) => event.event_id).filter(Boolean);
        let selectedEventId = eventOrder[0] || null;

        const section = document.createElement("section");
        section.className = "panel case";

        const head = document.createElement("div");
        head.className = "case-head";
        const title = document.createElement("h2");
        title.className = "case-title";
        title.textContent = caseConfig.title || "Case";
        const meta = document.createElement("div");
        meta.className = "case-meta";
        meta.textContent = `${formatTimestampShort(minTime.toISOString())} → ${formatTimestampShort(maxTime.toISOString())}`;
        head.appendChild(title);
        head.appendChild(meta);
        section.appendChild(head);

        const summary = document.createElement("div");
        summary.className = "summary";
        [
          `Series ID: ${cgm.series_id || "unknown"}`,
          `Samples: ${samples.length}`,
          `Unit: ${cgm.unit || "unknown"}`,
          `Events: ${events.length}`,
          `Metrics: ${metrics.length}`,
        ].forEach((item) => {
          const div = document.createElement("div");
          div.className = "stat";
          div.textContent = item;
          summary.appendChild(div);
        });
        section.appendChild(summary);

        const chartPanel = document.createElement("div");
        chartPanel.className = "chart-panel";
        const chartHeader = document.createElement("div");
        chartHeader.className = "chart-header";
        chartHeader.innerHTML = `
          <h2>CGM Timeline</h2>
          <div class="legend">
            <span><i></i> glucose response</span>
            <span>│ event markers</span>
          </div>
        `;
        chartPanel.appendChild(chartHeader);

        const canvas = document.createElement("canvas");
        const displayWidth = 1200;
        const displayHeight = 260;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = displayWidth * dpr;
        canvas.height = displayHeight * dpr;
        canvas.style.width = "100%";
        canvas.style.height = `${displayHeight}px`;
        chartPanel.appendChild(canvas);
        section.appendChild(chartPanel);

        const ctx = canvas.getContext("2d");
        ctx.scale(dpr, dpr);
        const padding = 46;
        const axisHeight = 46;
        const width = displayWidth;
        const height = displayHeight;
        const plotBottom = height - padding - axisHeight;
        const plotHeight = plotBottom - padding;
        const sampleTimes = samples.map((sample) => parseTimestamp(sample.timestamp).getTime());
        const sampleValues = samples.map((sample) => Number(sample.glucose_value));

        const drawChart = (eventId) => {
          ctx.clearRect(0, 0, width, height);
          drawGrid(ctx, width, height, padding, minValue, maxValue, axisHeight);

          const timeSpan = maxTime - minTime || 1;
          const xScale = (time) =>
            padding + ((time - minTime) / timeSpan) * (width - padding * 2);
          const yScale = (value) =>
            plotBottom -
            ((value - minValue) / (maxValue - minValue || 1)) * plotHeight;

          if (eventId) {
            const event = eventMap.get(eventId);
            if (event) {
              const eventTime = parseTimestamp(event.start_time).getTime();
              const baselineStart = eventTime - 15 * 60 * 1000;
              const baselineEnd = eventTime;
              const responseEnd = eventTime + 120 * 60 * 1000;
              drawWindowHighlight(
                ctx,
                baselineStart,
                baselineEnd,
                xScale,
                padding,
                plotBottom,
                "rgba(70, 140, 220, 0.12)"
              );
              drawWindowHighlight(
                ctx,
                eventTime,
                responseEnd,
                xScale,
                padding,
                plotBottom,
                "rgba(248, 196, 120, 0.16)"
              );

              const threshold = cgm.unit === "mmol/L" ? 7.8 : 7.8 * 18.0;
              drawThresholdFill(
                ctx,
                sampleTimes,
                sampleValues,
                eventTime,
                responseEnd,
                threshold,
                xScale,
                yScale,
                plotBottom,
                "rgba(192, 74, 43, 0.22)"
              );
            }
          }

          const points = samples.map((sample, idx) => [
            xScale(parseTimestamp(sample.timestamp)),
            yScale(sample.glucose_value),
          ]);
          drawLine(ctx, points);

          if (events.length) {
            drawEvents(ctx, events, xScale, padding, plotBottom, eventId);
          }

          drawTimeAxis(ctx, minTime, maxTime, xScale, padding, width, plotBottom, axisHeight);
          drawAxisLabels(ctx, width, height, padding, plotBottom, cgm.unit);
        };

        drawChart(selectedEventId);

        const details = document.createElement("div");
        details.className = "case-details two-up";

        const eventsPanel = document.createElement("section");
        eventsPanel.className = "panel subpanel events";
        const eventsTitle = document.createElement("h3");
        eventsTitle.textContent = "Events";
        const eventsNote = document.createElement("p");
        eventsNote.className = "note";
        eventsNote.textContent = "Click an event to highlight baseline/response windows on the timeline.";

        const metricsPanel = document.createElement("section");
        metricsPanel.className = "panel subpanel metrics";
        const metricsTitle = document.createElement("h3");
        metricsTitle.textContent = "Metrics";
        const metricsNote = document.createElement("p");
        metricsNote.className = "note";
        metricsNote.textContent = "Signals use coverage + core metrics; triggers list why a card is red/yellow/gray.";

        const refreshSelections = () => {
          eventsPanel.replaceChildren(eventsTitle, renderEventsList(events, selectedEventId, onSelectEvent), eventsNote);
          metricsPanel.replaceChildren(
            metricsTitle,
            renderMetricsList(metrics, eventMap, signalsMap, selectedEventId, onSelectEvent),
            metricsNote
          );
        };

        const onSelectEvent = (eventId) => {
          selectedEventId = eventId;
          drawChart(selectedEventId);
          refreshSelections();
        };

        eventsPanel.appendChild(eventsTitle);
        eventsPanel.appendChild(renderEventsList(events, selectedEventId, onSelectEvent));
        eventsPanel.appendChild(eventsNote);

        metricsPanel.appendChild(metricsTitle);
        metricsPanel.appendChild(renderMetricsList(metrics, eventMap, signalsMap, selectedEventId, onSelectEvent));
        metricsPanel.appendChild(metricsNote);

        details.appendChild(eventsPanel);
        details.appendChild(metricsPanel);
        section.appendChild(details);

        return section;
      }

      function renderGlossary() {
        const panel = document.createElement("section");
        panel.className = "panel";
        const title = document.createElement("h2");
        title.className = "case-title";
        title.textContent = "Metrics Glossary";
        panel.appendChild(title);

        const list = document.createElement("ul");
        list.className = "metrics-glossary";
        list.innerHTML = `
          <li><strong>baseline_glucose</strong> — mean glucose in the 30 minutes before the event.</li>
          <li><strong>iAUC_0-120</strong> — incremental area under the curve above baseline in the first 120 minutes.</li>
          <li><strong>delta_peak</strong> — peak glucose minus baseline (used for signals).</li>
          <li><strong>time_to_peak</strong> — minutes from event start to max glucose.</li>
          <li><strong>nadir_glucose</strong> — minimum glucose value within 0–180 minutes.</li>
          <li><strong>recovery_slope</strong> — linear slope during the recovery window; negative means falling (recovery), positive means rising. “return %” compares recovery end to baseline.</li>
        `;
        panel.appendChild(list);
        return panel;
      }

      async function render() {
        const { data: casesIndex, baseDir } = await loadCaseIndex();
        let cases = [];

        if (casesIndex?.cases?.length) {
          cases = sortCases(casesIndex.cases).map((caseConfig) => ({
            ...caseConfig,
            path: resolveCasePath(caseConfig, baseDir),
          }));
        } else {
          const defaultPath = await resolveDefaultPath();
          cases = [{ title: "Latest run", path: defaultPath }];
        }

        const root = document.getElementById("cases");
        const controls = document.getElementById("case-controls");
        root.innerHTML = "";
        controls.innerHTML = "";

        const renderSelection = async (index) => {
          root.innerHTML = "";
          const section = await renderCase(cases[index]);
          root.appendChild(section);
          root.appendChild(renderGlossary());
        };

        if (cases.length > 1) {
          const label = document.createElement("label");
          label.textContent = "Select case";
          const select = document.createElement("select");
          select.className = "case-select";
          cases.forEach((caseConfig, idx) => {
            const option = document.createElement("option");
            option.value = String(idx);
            option.textContent = caseConfig.title || `Case ${idx + 1}`;
            select.appendChild(option);
          });
          controls.appendChild(label);
          controls.appendChild(select);
          select.addEventListener("change", (event) => {
            const idx = Number(event.target.value);
            renderSelection(Number.isFinite(idx) ? idx : 0);
          });
        }

        await renderSelection(0);
      }

      render();

      async function resolveDefaultPath() {
        const outputCase = await loadJson("../output/cgm.json");
        if (outputCase) return "../output";
        const localCase = await loadJson("./cgm.json");
        if (localCase) return ".";
        return "../output";
      }
    </script>
  </body>
</html>
